<?php

namespace LittleApps\LittleJWT;

use Closure;

use Illuminate\Contracts\Foundation\Application;

use Jose\Component\Core\JWK;

use LittleApps\LittleJWT\Build\Build;
use LittleApps\LittleJWT\Build\Builders\DefaultBuilder;
use LittleApps\LittleJWT\Build\Builders\StackBuilder;
use LittleApps\LittleJWT\Contracts\Buildable;
use LittleApps\LittleJWT\Contracts\Validatable;
use LittleApps\LittleJWT\Exceptions\CantParseJWTException;
use LittleApps\LittleJWT\Factories\JWTBuilder;
use LittleApps\LittleJWT\JWT\JWT;
use LittleApps\LittleJWT\Validation\Valid;
use LittleApps\LittleJWT\Validation\Validators\DefaultValidator;
use LittleApps\LittleJWT\Validation\Validators\StackValidator;

class LittleJWT
{
    /**
     * Application container
     *
     * @var Application
     */
    protected $app;

    /**
     * The JWK to use for building and validating JWTs
     *
     * @var JWK
     */
    protected $jwk;

    public function __construct(Application $app, JWK $jwk)
    {
        $this->app = $app;
        $this->jwk = $jwk;
    }

    /**
     * Creates a signed JWT
     *
     * @param \Closure $callback Callback that receives LittleApps\LittleJWT\Builder instance
     * @param bool $applyDefault If true, the default claims are applied to the JWT. (default is true)
     * @return string
     */
    public function createToken(Closure $callback = null, $applyDefault = true)
    {
        return (string) $this->createJWT($callback, $applyDefault);
    }

    /**
     * Creates a signed JWT instance.
     *
     * @param callable|Buildable $callback Callback or Buildable that recieves Builder build JWT.
     * @param bool $applyDefault If true, the default claims are applied to the JWT. (default is true)
     * @return JWT
     */
    public function createJWT($callback = null, $applyDefault = true)
    {
        $build = $this->buildJWT($callback, $applyDefault);

        return $build->build();
    }

    /**
     * Creates a signed JWT instance.
     *
     * @param callable|Buildable $callback Callback or Buildable that recieves Builder build JWT.
     * @param bool $applyDefault If true, the default claims are applied to the JWT. (default is true)
     * @return Build
     */
    public function buildJWT($callback = null, $applyDefault = true)
    {
        if (is_object($callback) && $callback instanceof Buildable) {
            $buildable = $callback;
        } else {
            $callbacks = [];

            if ($applyDefault) {
                array_push($callbacks, $this->getDefaultBuildableCallback());
            }

            if (is_callable($callback)) {
                array_push($callbacks, $callback);
            }

            $buildable = new StackBuilder($callbacks);
        }

        $build = new Build($this->app, $this->jwk, $buildable);

        return $build;
    }

    /**
     * Builds a JWT instance from a string.
     * This does NOT check that the JWT is valid.
     *
     * @param string $token
     * @return \LittleApps\LittleJWT\JWT\JWT|null Returns JWT or null if token cannot be parsed.
     */
    public function parseToken(string $token)
    {
        $builder = $this->app->make(JWTBuilder::class);

        try {
            return $builder->buildFromExisting($token);
        } catch (CantParseJWTException) {
            return null;
        }
    }

    /**
     * Creates a Valid instance for checking if a JWT is valid.
     *
     * @param JWT $jwt JWT instance to validate (generated by parseToken() method)
     * @param callable|Validatable $callback Callback or Validatable that recieves Validator to set checks for JWT.
     * @return Valid Valid instance (before validation is done)
     */
    public function validJWT(JWT $jwt, $callback = null, $applyDefault = true)
    {
        if (is_object($callback) && $callback instanceof Validatable) {
            $validatable = $callback;
        } else {
            $callbacks = [];

            if ($applyDefault) {
                array_push($callbacks, $this->getDefaultValidatorCallback());
            }

            if (is_callable($callback)) {
                array_push($callbacks, $callback);
            }

            $validatable = new StackValidator($callbacks);
        }

        $valid = new Valid($this->app, $jwt, $this->jwk, $validatable);

        return $valid;
    }

    /**
     * Checks that a JWT is valid.
     *
     * @param JWT $jwt JWT instance to validate (generated by parseToken() method)
     * @param callable|Validatable $callback Callback or Validatable that recieves Validator to set checks for JWT.
     * @return bool True if token is valid.
     */
    public function validateJWT(JWT $jwt, $callback = null, $applyDefault = true)
    {
        return $this->validJWT($jwt, $callback, $applyDefault)->passes();
    }

    /**
     * Checks that a token is valid.
     *
     * @param string $token JWT as string to validate.
     * @param callable|Validatable $callback Callback or Validatable that recieves Validator to set checks for JWT.
     * @return bool True if token is valid.
     */
    public function validateToken(string $token, $callback = null, $applyDefault = true)
    {
        $jwt = $this->parseToken($token);

        return ! is_null($jwt) ? $this->validateJWT($jwt, $callback, $applyDefault) : false;
    }

    /**
     * Gets the default buildable callback.
     *
     * @return callable
     */
    protected function getDefaultBuildableCallback()
    {
        $buildable = $this->app->make(DefaultBuilder::class);

        return [$buildable, 'build'];
    }

    /**
     * Gets the default Validatable callback.
     *
     * @return callable
     */
    protected function getDefaultValidatorCallback()
    {
        $validatable = $this->app->make(DefaultValidator::class);

        return [$validatable, 'validate'];
    }
}
